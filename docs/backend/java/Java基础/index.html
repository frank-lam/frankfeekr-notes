<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-backend/java/Java基础">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.18">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="技术小匠·笔记 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="技术小匠·笔记 Atom Feed"><title data-rh="true">Java 基础知识 | 技术小匠·笔记</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://notes.frankfeekr.cn/docs/backend/java/Java基础"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java 基础知识 | 技术小匠·笔记"><meta data-rh="true" name="description" content="前言"><meta data-rh="true" property="og:description" content="前言"><link data-rh="true" rel="icon" href="/img/Landscape.svg"><link data-rh="true" rel="canonical" href="https://notes.frankfeekr.cn/docs/backend/java/Java基础"><link data-rh="true" rel="alternate" href="https://notes.frankfeekr.cn/docs/backend/java/Java基础" hreflang="en"><link data-rh="true" rel="alternate" href="https://notes.frankfeekr.cn/docs/backend/java/Java基础" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.20bf4ac0.css">
<link rel="preload" href="/assets/js/runtime~main.44680fd1.js" as="script">
<link rel="preload" href="/assets/js/main.76edb368.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_ObN2"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/idea.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/idea.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">技术小匠·笔记</b></a><a class="navbar__item navbar__link" href="/docs/introduction/readme">前言</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">后台架构</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link navbar__link--active" href="/docs/backend/java/Java基础">Java 基础知识</a></li><li><a class="dropdown__link" href="/docs/backend/intro">总览</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">前端技术</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/frontend/es6/项目准备/前言">ECMAScript2015~2020语法全解析</a></li><li><a class="dropdown__link" href="/docs/frontend/angular/">Angualr</a></li><li><a class="dropdown__link" href="/docs/category/ecmascript20152020语法全解析">总览</a></li></ul></div><a class="navbar__item navbar__link" href="/docs/tools/Visual Studio Code">技术工具</a><a class="navbar__item navbar__link" href="/docs/about/readme">关于本站</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">常用工具</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/search">🔍 本站搜索</a></li><li><a href="https://www.emojiall.com/zh-hans/all-emojis" target="_blank" rel="noopener noreferrer" class="dropdown__link">😄 EMOJIALL<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://tools.frankfeekr.cn/" target="_blank" rel="noopener noreferrer" class="dropdown__link">🧭 LinTools - 开发者的在线导航<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://frankfeekr.cn/" target="_blank" rel="noopener noreferrer" class="dropdown__link">👨‍💻 frankfeekr.cn - 我的博客<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Links</a><ul class="dropdown__menu"><li><a href="https://github.com/frank-lam/frankfeekr-notes/issues" target="_blank" rel="noopener noreferrer" class="dropdown__link">Issues<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/frank-lam/frankfeekr-notes/actions" target="_blank" rel="noopener noreferrer" class="dropdown__link">Actions<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://github.com/frank-lam/fullstack-tutorial" target="_blank" rel="noopener noreferrer" class="dropdown__link">GitHub<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="toggle_S7eR colorModeToggle_vKtC"><button class="clean-btn toggleButton_rCf9 toggleButtonDisabled_Pu9x" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbar__search searchBarContainer_NW3z"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_RiAD sidebarWithHideableNavbar_d0QC"><a tabindex="-1" class="sidebarLogo_YUvz" href="/"><img src="/img/idea.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/idea.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"><b>技术小匠·笔记</b></a><nav class="menu thin-scrollbar menu_izAj"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/backend/java/Java基础">Java 基础知识</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/backend/java/Java集合框架">Java 集合框架</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/backend/java/Java并发编程">Java 并发编程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/backend/java/Java-IO">Java IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/backend/java/Java虚拟机">Java 虚拟机</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/backend/java/Java设计模式">Java 设计模式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/backend/java/JavaWeb">Java Web</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/backend/java/系统架构">系统架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/backend/java/Overview">Overview</a></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_FykI"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_DTRl"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Xlws" aria-label="breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/">🏠</a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="item name">Java 基础知识</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Java 基础知识</h1><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="前言">前言<a class="hash-link" href="#前言" title="Direct link to heading">​</a></h2><p>本文主要包含 Java 核心基础知识，主要根据以下部分进行节选，选择了个人认为在面试中最为核心的部分。</p><ul><li><p>《Java程序员面试笔试宝典》何昊，薛鹏，叶向阳 著</p></li><li><p><a href="https://blog.csdn.net/sinat_22797429/article/details/76293284" target="_blank" rel="noopener noreferrer">《阿里面经OneNote》</a></p><p>主要内容：基本概念、面向对象、关键字、基本数据类型与运算、字符串与数组、异常处理、Object 通用方法</p></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="一基本概念">一、基本概念<a class="hash-link" href="#一基本概念" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="1-java程序初始化的顺序是怎么样的">1. Java程序初始化的顺序是怎么样的<a class="hash-link" href="#1-java程序初始化的顺序是怎么样的" title="Direct link to heading">​</a></h3><p>　　在 Java 语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建象。</p><p><strong>初始化一般遵循3个原则：</strong></p><ul><li>静态对象（变量）优先于非静态对象（变量）初始化，静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化多次；</li><li>父类优先于子类进行初始化；</li><li>按照成员变量的定义顺序进行初始化。 即使变量定义散布于方法定义之中，它们依然在任何方法（包括构造函数）被调用之前先初始化；</li></ul><p><strong>加载顺序</strong></p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><p><strong>实例</strong> </p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Base {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 1.父类静态代码块</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    static {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;Base static block!&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 3.父类非静态代码块</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;Base block&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 4.父类构造器</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public Base() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;Base constructor!&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Derived extends Base {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 2.子类静态代码块</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    static{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;Derived static block!&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 5.子类非静态代码块</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;Derived block!&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 6.子类构造器</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public Derived() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;Derived constructor!&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        new Derived();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>结果是：</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Base static block!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Derived static block!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Base block</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Base constructor!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Derived block!</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Derived constructor!</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="2-java和c的区别">2. Java和C++的区别<a class="hash-link" href="#2-java和c的区别" title="Direct link to heading">​</a></h3><ul><li>Java 是<strong>纯粹的面向对象语言</strong>，所有的对象都继承自 java.lang.Object，<strong>C++ 为了兼容 C 即支持面向对象也支持面向过程</strong>。</li><li>Java 通过虚拟机从而实现<strong>跨平台特性</strong>，但是 C++ 依赖于<strong>特定的平台</strong>。</li><li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li><li>Java 支持<strong>自动垃圾回收</strong>，而 C++ 需要<strong>手动回收</strong>。（C++11 中引入智能指针，使用引用计数法垃圾回收）</li><li><strong>Java 不支持多重继承</strong>，只能通过实现多个接口来达到相同目的，而 <strong>C++ 支持多重继承</strong>。</li><li>Java 不支持操作符重载，虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li><li>Java 内置了线程的支持，而 C++ 需要依靠第三方库。</li><li>Java 的 <strong>goto 是保留字</strong>，但是不可用，C++ 可以使用 goto。</li><li>Java <strong>不支持条件编译</strong>，C++ 通过 #ifdef #ifndef 等预处理命令从而实现<strong>条件编译</strong>。</li></ul><p>参考资料：</p><ul><li><a href="http://www.cnblogs.com/Solstice/archive/2011/08/16/2141515.html" target="_blank" rel="noopener noreferrer">C++ 工程实践(8)：值语义 - 陈硕 - 博客园</a></li><li><a href="https://www.cnblogs.com/qicosmos/p/3282779.html" target="_blank" rel="noopener noreferrer">c++11改进我们的程序之垃圾回收</a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="3-反射">3. 反射<a class="hash-link" href="#3-反射" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="先看一个知乎回答">先看一个知乎回答<a class="hash-link" href="#先看一个知乎回答" title="Direct link to heading">​</a></h4><p>　　首先看一个在知乎上的优秀回答吧：</p><p>　　反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到 JVM，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻。</p><p>　　举个例子我们的项目底层有时是用 mysql，有时用 oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection 这两个类我们要用，这时候我们的程序就写得比较动态化，通过 Class tc = Class.forName(&quot;com.java.dbtest.TestConnection&quot;); 通过类的全类名让 JVM 在服务器中找到并加载这个类，而如果是 Oracle 则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出 Java 的特性了！</p><p>　　举多个例子，大家如果接触过 spring，会发现当你配置各种各样的 bean 时，是以配置文件的形式配置的，你需要用到哪些 bean 就配哪些，spring 容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="什么是反射">什么是反射<a class="hash-link" href="#什么是反射" title="Direct link to heading">​</a></h4><p>　　反射 (Reflection) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过 Class 获取 class 信息称之为反射（Reflection）</p><p>　　简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。</p><p>　　程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>　　反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>　　Java 反射框架主要提供以下功能：</p><p>　　1. 在运行时判断任意一个对象所属的类</p><p>　　2. 在运行时构造任意一个类的对象</p><p>　　3. 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用 private 方法）</p><p>　　4. 在运行时调用任意一个对象的方法</p><p>　　<strong>重点</strong>：是运行时而不是编译时</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="主要用途">主要用途<a class="hash-link" href="#主要用途" title="Direct link to heading">​</a></h4><p>　　很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。</p><p>当我们在使用 IDE （如Eclipse，IDEA）时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p><p>　　<strong>反射最重要的用途就是开发各种通用框架</strong></p><p>　　很多框架（比如 Spring ）都是配置化的（比如通过 XML 文件配置 JavaBean,Action 之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p><p>　　对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="获得class对象">获得Class对象<a class="hash-link" href="#获得class对象" title="Direct link to heading">​</a></h4><ol><li>调用运行时类本身的 <code>.class</code> 属性</li></ol><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Class clazz1 = Person.class;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(clazz1.getName());</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ol start="2"><li>通过运行时类的对象获取 <code>getClass();</code></li></ol><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Person p = new Person();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Class clazz3 = p.getClass();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(clazz3.getName());</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ol start="3"><li>使用 Class 类的 <code>forName</code> 静态方法</li></ol><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static Class&lt;?&gt; forName(String className)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 在JDBC开发中常用此方法加载数据库驱动:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Class.forName(driver);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ol start="4"><li>（了解）通过类的加载器 ClassLoader</li></ol><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">ClassLoader classLoader = this.getClass().getClassLoader();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Class clazz5 = classLoader.loadClass(className);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(clazz5.getName());</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>参考资料：</p><ul><li><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F" target="_blank" rel="noopener noreferrer">深入解析Java反射（1） - 基础 | 「浮生若梦」 - sczyh30&#x27;s blog</a></li><li><a href="https://www.zhihu.com/question/24304289/answer/147529485" target="_blank" rel="noopener noreferrer">学习java应该如何理解反射？ - 知乎</a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="4-注解">4. 注解<a class="hash-link" href="#4-注解" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="什么是注解">什么是注解<a class="hash-link" href="#什么是注解" title="Direct link to heading">​</a></h4><p>　　Annontation 是 Java5 开始引入的新特征，中文名称叫注解。它提供了一种安全的类似注释的机制，用来<strong>将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</strong>。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation 像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p><p>　　Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 <code> java.lang.annotation</code> 包中。</p><p>　　简单来说：注解其实就是<strong>代码中的特殊标记</strong>，这些标记可以<strong>在编译、类加载、运行时被读取，并执行相对应的处理</strong>。 </p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="为什么要用注解">为什么要用注解<a class="hash-link" href="#为什么要用注解" title="Direct link to heading">​</a></h4><p>传统的方式，我们是通过配置文件 <code>.xml</code> 来告诉类是如何运行的。</p><p>有了注解技术以后，我们就可以通过注解告诉类如何运行</p><p>例如：我们以前编写 Servlet 的时候，需要在 web.xml 文件配置具体的信息。我们使用了注解以后，可以直接在 Servlet 源代码上，增加注解...Servlet 就被配置到 Tomcat 上了。也就是说，注解可以给类、方法上注入信息。</p><p>明显地可以看出，这样是非常直观的，并且 Servlet 规范是推崇这种配置方式的。 </p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="基本annotation">基本Annotation<a class="hash-link" href="#基本annotation" title="Direct link to heading">​</a></h4><p>在 java.lang 包下存在着5个基本的 Annotation，重点掌握前三个。</p><ol><li><p>@Override 重写注解</p><ul><li>如果我们使用IDE重写父类的方法，我们就可以看见它了。</li><li>@Override是告诉编译器要检查该方法是实现父类的，可以帮我们避免一些低级的错误。</li><li>比如，我们在实现 equals() 方法的时候，把 euqals() 打错了，那么编译器就会发现该方法并不是实现父类的，与注解 @Override 冲突，于是就会给予错误。</li></ul></li><li><p>@Deprecated 过时注解</p><ul><li>该注解也非常常见，Java 在设计的时候，可能觉得某些方法设计得不好，为了兼容以前的程序，是不能直接把它抛弃的，于是就设置它为过时。</li><li>Date对象中的 toLocalString() 就被设置成过时了</li><li>当我们在程序中调用它的时候，在 IDE 上会出现一条横杠，说明该方法是过时的。</li></ul></li></ol><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@Deprecated</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public String toLocaleString() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    DateFormat formatter = DateFormat.getDateTimeInstance();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return formatter.format(this);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ol start="3"><li><p>@SuppressWarnings 抑制编译器警告注解</p><ul><li>该注解在我们写程序的时候并不是很常见，我们可以用它来让编译器不给予我们警告</li><li>当我们在使用集合的时候，如果没有指定泛型，那么会提示安全检查的警告</li><li>如果我们在类上添加了@SuppressWarnings这个注解，那么编译器就不会给予我们警告了 </li></ul></li><li><p>@SafeVarargs Java 7“堆污染”警告</p><ul><li>什么是堆污染呢？？当把一个不是泛型的集合赋值给一个带泛型的集合的时候，这种情况就很容易发生堆污染。</li><li>这个注解也是用来抑制编译器警告的注解，用的地方并不多。</li></ul></li><li><p>@FunctionalInterface 用来指定该接口是函数式接口</p><ul><li>用该注解显式指定该接口是一个函数式接口。</li></ul></li></ol><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="自定义注解类编写规则">自定义注解类编写规则<a class="hash-link" href="#自定义注解类编写规则" title="Direct link to heading">​</a></h4><ol><li>Annotation 型定义为 @interface, 所有的 Annotation 会自动继承 java.lang.Annotation 这一接口，并且不能再去继承别的类或是接口.</li><li>参数成员只能用 public 或默认(default)这两个访问权修饰</li><li>参数成员只能用基本类型 byte,short,char,int,long,float,double,boolean 八种基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这一些类型的数组</li><li>要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</li><li>注解也可以没有定义成员, 不过这样注解就没啥用了
PS：自定义注解需要使用到元注解</li></ol><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="自定义注解实例">自定义注解实例<a class="hash-link" href="#自定义注解实例" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">import java.lang.annotation.Documented;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">import java.lang.annotation.Retention;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">import java.lang.annotation.Target;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">import static java.lang.annotation.ElementType.FIELD;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">import static java.lang.annotation.RetentionPolicy.RUNTIME;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> * 水果名称注解</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@Target(FIELD)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@Retention(RUNTIME)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">@Documented</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public @interface FruitName {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    String value() default &quot;&quot;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p> 参考资料：<a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener noreferrer">注解Annotation实现原理与自定义注解例子</a></p><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="5-泛型">5. 泛型<a class="hash-link" href="#5-泛型" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="通俗解释">通俗解释<a class="hash-link" href="#通俗解释" title="Direct link to heading">​</a></h4><p>　　通俗的讲，泛型就是操作类型的 占位符，即：假设占位符为 T，那么此次声明的数据结构操作的数据类型为T类型。</p><p>　　假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？答案是可以使用 <strong>Java 泛型</strong>。</p><p>　　使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="泛型方法">泛型方法<a class="hash-link" href="#泛型方法" title="Direct link to heading">​</a></h4><p>　　你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p><p>下面是定义泛型方法的规则：</p><ul><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的 <code>&lt;E&gt;</code>）。</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li><li>泛型方法体的声明和其他方法一样。注意类型参数 <strong>只能代表引用型类型，不能是原始类型</strong> （像 int,double,char 的等）。</li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class GenericMethodTest</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   // 泛型方法 printArray                         </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   public static &lt; E &gt; void printArray( E[] inputArray )</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      // 输出数组元素            </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         for ( E element : inputArray ){        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            System.out.printf( &quot;%s &quot;, element );</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         System.out.println();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main( String args[] )</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // 创建不同类型数组： Integer, Double 和 Character</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Integer[] intArray = { 1, 2, 3, 4, 5 };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Character[] charArray = { &#x27;H&#x27;, &#x27;E&#x27;, &#x27;L&#x27;, &#x27;L&#x27;, &#x27;O&#x27; };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println( &quot;整型数组元素为:&quot; );</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        printArray( intArray  ); // 传递一个整型数组</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println( &quot;\n双精度型数组元素为:&quot; );</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        printArray( doubleArray ); // 传递一个双精度型数组</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println( &quot;\n字符型数组元素为:&quot; );</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        printArray( charArray ); // 传递一个字符型数组</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="泛型类">泛型类<a class="hash-link" href="#泛型类" title="Direct link to heading">​</a></h4><p>　　泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。</p><p>　　和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Box&lt;T&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private T t;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public void add(T t) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        this.t = t;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public T get() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return t;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Box&lt;String&gt; stringBox = new Box&lt;String&gt;();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        integerBox.add(new Integer(10));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        stringBox.add(new String(&quot;菜鸟教程&quot;));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.printf(&quot;整型值为 :%d\n\n&quot;, integerBox.get());</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.printf(&quot;字符串为 :%s\n&quot;, stringBox.get());</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="类型通配符">类型通配符<a class="hash-link" href="#类型通配符" title="Direct link to heading">​</a></h4><ol><li><p>类型通配符一般是使用 <code>?</code> 代替具体的类型参数。例如  <code>List&lt;?&gt;</code> 在逻辑上是 <code>List&lt;String&gt;</code>，<code>List&lt;Integer&gt;</code> 等所有 <strong>List&lt;具体类型实参&gt;</strong> 的父类。  </p></li><li><p>类型通配符上限通过形如 List 来定义，如此定义就是通配符泛型值接受 Number 及其下层子类类型。  </p></li><li><p>类型通配符下限通过形如 List&lt;? super Number&gt; 来定义，表示类型只能接受 Number 及其三层父类类型，如 Objec 类型的实例。  </p></li></ol><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/demingblog/p/5495610.html" target="_blank" rel="noopener noreferrer">Java 泛型，了解这些就够用了。 - 逃离沙漠 - 博客园</a></li><li><a href="http://www.runoob.com/java/java-generics.html" target="_blank" rel="noopener noreferrer">Java 泛型 | 菜鸟教程</a></li><li><a href="https://www.cnblogs.com/xltcjylove/p/3671943.html" target="_blank" rel="noopener noreferrer">【Java心得总结四】Java泛型下——万恶的擦除 - xlturing - 博客园</a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="6-字节与字符的区别">6. 字节与字符的区别<a class="hash-link" href="#6-字节与字符的区别" title="Direct link to heading">​</a></h3><p>理解编码的关键，是要把字符的概念和字节的概念理解准确。这两个概念容易混淆，我们在此做一下区分：</p><table><thead><tr><th>类型</th><th><strong>概念描述</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>字符</td><td>人们使用的记号，抽象意义上的一个符号。</td><td>&#x27;1&#x27;, &#x27;中&#x27;, &#x27;a&#x27;, &#x27;$&#x27;, &#x27;￥&#x27;, ……</td></tr><tr><td>字节</td><td>计算机中存储数据的单元，一个 8 位的二进制数，是一个很具体的存储空间。</td><td>0x01, 0x45, 0xFA, ……</td></tr><tr><td>ANSI 字符串</td><td>在内存中，如果“字符”是以 <strong>ANSI 编码</strong>形式存在的，一个字符可能使用一个字节或多个字节来表示，那么我们称这种字符串为 <strong>ANSI 字符串</strong>或者<strong>多字节字符串</strong>。</td><td>&quot;中文123&quot; （占7字节）</td></tr><tr><td>UNICODE 字符串</td><td>在内存中，如果“字符”是以在 UNICODE 中的序号存在的，那么我们称这种字符串为 <strong>UNICODE 字符串</strong>或者<strong>宽字节字符串</strong>。</td><td>L&quot;中文123&quot; （占10字节）</td></tr></tbody></table><p><strong>字节与字符区别</strong></p><p>它们完全不是一个位面的概念，所以两者之间没有“区别”这个说法。不同编码里，字符和字节的对应关系不同：</p><table><thead><tr><th>类型</th><th><strong>概念描述</strong></th></tr></thead><tbody><tr><td>ASCII</td><td>一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为 8 位二进制数，换算为十进制。最小值 0，最大值 255。</td></tr><tr><td>UTF-8</td><td>一个英文字符等于一个字节，一个中文（含繁体）等于三个字节</td></tr><tr><td>Unicode</td><td>一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占 1 个字节的大小，中文句号“。”占 2 个字节的大小。</td></tr><tr><td>UTF-16</td><td>一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode扩展区的一些汉字存储需要4个字节）</td></tr><tr><td>UTF-32</td><td>世界上任何字符的存储都需要 4 个字节</td></tr></tbody></table><p>参考资料：</p><ul><li><a href="http://www.regexlab.com/zh/encoding.htm" target="_blank" rel="noopener noreferrer">字符，字节和编码 - Characters, Bytes And Encoding</a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="7-有哪些访问修饰符">7. 有哪些访问修饰符<a class="hash-link" href="#7-有哪些访问修饰符" title="Direct link to heading">​</a></h3><p>Java 面向对象的基本思想之一是封装细节并且公开接口。Java 语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为四种级别：</p><table><thead><tr><th>修饰符</th><th>当前类</th><th>同 包</th><th>子 类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。</li><li>受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</li><li>Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种。 </li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="8-深拷贝与浅拷贝">8. 深拷贝与浅拷贝<a class="hash-link" href="#8-深拷贝与浅拷贝" title="Direct link to heading">​</a></h3><ul><li><strong>浅拷贝</strong>：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所拷贝的对象，而不复制它所引用的对象。</li></ul><div align="center"> <img loading="lazy" src="assets/shadow_copy2.jpg" width="550" class="img_E7b_"></div><ul><li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ul><div align="center"> <img loading="lazy" src="assets/deep_copy2.jpg" width="550" class="img_E7b_"></div><p>参考资料：</p><ul><li><a href="https://segmentfault.com/a/1190000010648514" target="_blank" rel="noopener noreferrer">细说 Java 的深拷贝和浅拷贝 - 承香墨影 - SegmentFault 思否</a></li><li><a href="https://juejin.im/post/59bfc707f265da0646188bca" target="_blank" rel="noopener noreferrer">（基础系列）object clone 的用法、原理和用途 - 掘金</a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="9-lamda表达式">9. Lamda表达式<a class="hash-link" href="#9-lamda表达式" title="Direct link to heading">​</a></h3><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="语法">语法<a class="hash-link" href="#语法" title="Direct link to heading">​</a></h4><p>lambda 表达式的语法格式如下：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">(parameters) -&gt; expression</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">或</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">(parameters) -&gt; { statements; }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>以下是 lambda 表达式的重要特征:</p><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="lambda-表达式实例">Lambda 表达式实例<a class="hash-link" href="#lambda-表达式实例" title="Direct link to heading">​</a></h4><p>Lambda 表达式的简单例子:</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 1. 不需要参数,返回值为 5  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">() -&gt; 5  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 2. 接收一个参数(数字类型),返回其2倍的值  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">x -&gt; 2 * x  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 3. 接受2个参数(数字),并返回他们的差值  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">(x, y) -&gt; x – y  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 4. 接收2个int型整数,返回他们的和  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">(int x, int y) -&gt; x + y  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">(String s) -&gt; System.out.print(s)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>在 Java8Tester.java 文件输入以下代码：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Java8Tester {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   public static void main(String args[]){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      Java8Tester tester = new Java8Tester();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      // 类型声明</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      MathOperation addition = (int a, int b) -&gt; a + b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      // 不用类型声明</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      MathOperation subtraction = (a, b) -&gt; a - b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      // 大括号中的返回语句</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      MathOperation multiplication = (int a, int b) -&gt; { return a * b; };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      // 没有大括号及返回语句</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      MathOperation division = (int a, int b) -&gt; a / b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      // 不用括号</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      GreetingService greetService1 = message -&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println(&quot;Hello &quot; + message);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      // 用括号</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      GreetingService greetService2 = (message) -&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println(&quot;Hello &quot; + message);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      greetService1.sayMessage(&quot;Runoob&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      greetService2.sayMessage(&quot;Google&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   interface MathOperation {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      int operation(int a, int b);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   interface GreetingService {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      void sayMessage(String message);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   private int operate(int a, int b, MathOperation mathOperation){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      return mathOperation.operation(a, b);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>执行以上脚本，输出结果为：</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ javac Java8Tester.java </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ java Java8Tester</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">10</span><span class="token plain"> + </span><span class="token number" style="color:rgb(247, 140, 108)">5</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">15</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">10</span><span class="token plain"> - </span><span class="token number" style="color:rgb(247, 140, 108)">5</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">5</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">10</span><span class="token plain"> x </span><span class="token number" style="color:rgb(247, 140, 108)">5</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">50</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">10</span><span class="token plain"> / </span><span class="token number" style="color:rgb(247, 140, 108)">5</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">2</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Hello Runoob</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Hello Google</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>使用 Lambda 表达式需要注意以下两点：</p><ul><li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的 Lambda 表达式来定义 MathOperation 接口的方法。然后我们定义了 sayMessage 的执行。</li><li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予 Java 简单但是强大的函数化的编程能力。</li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="变量作用域">变量作用域<a class="hash-link" href="#变量作用域" title="Direct link to heading">​</a></h4><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p><p>在 Java8Tester.java 文件输入以下代码：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Java8Tester {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   final static String salutation = &quot;Hello! &quot;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   public static void main(String args[]){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      GreetingService greetService1 = message -&gt; </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println(salutation + message);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      greetService1.sayMessage(&quot;Runoob&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   interface GreetingService {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      void sayMessage(String message);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>执行以上脚本，输出结果为：</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ javac Java8Tester.java </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ java Java8Tester</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Hello</span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token plain"> Runoob</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>我们也可以直接在 lambda 表达式中访问外层的局部变量：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Java8Tester {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        final int num = 1;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        s.convert(2);  // 输出结果为 3</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public interface Converter&lt;T1, T2&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        void convert(int i);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">int num = 1;  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">s.convert(2);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">num = 5;  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//报错信息：Local variable num defined in an enclosing scope must be final or effectively </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> final</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">String first = &quot;&quot;; </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//编译会出错</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length()); </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="10-字符串常量池">10. 字符串常量池<a class="hash-link" href="#10-字符串常量池" title="Direct link to heading">​</a></h3><p>　　Java 中字符串对象创建有两种形式，一种为字面量形式，如 <code>String str = &quot;abc&quot;;</code>，另一种就是使用 new 这种标准的构造对象的方法，如 <code>String str = new String(&quot;abc&quot;);</code>，这两种方式我们在代码编写时都经常使用，尤其是字面量的方式。然而<strong>这两种实现其实存在着一些性能和内存占用的差别</strong>。这一切都是源于 JVM 为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为<strong>字符串常量池</strong>或者<strong>字符串字面量池</strong>。</p><p><strong>工作原理</strong></p><p>　　当代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Test {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        String s1 = &quot;abc&quot;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        String s2 = &quot;abc&quot;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // 以上两个局部变量都存在了常量池中</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(s1 == s2); // true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // new出来的对象不会放到常量池中,内存地址是不同的</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        String s3 = new String();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        String s4 = new String();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        * 字符串的比较不可以使用双等号,这样会比较内存地址</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        * 字符串比较应当用equals,可见String重写了equals</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(s3 == s4); // false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(s3.equals(s4)); // true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="11-解释型语言与编译型语言的区别">11. 解释型语言与编译型语言的区别<a class="hash-link" href="#11-解释型语言与编译型语言的区别" title="Direct link to heading">​</a></h3><p>　　我们使用工具编写的字母加符号的代码，是我们能看懂的高级语言，计算机无法直接理解，计算机需要先对我们编写的代码翻译成计算机语言，才能执行我们编写的程序。</p><p>　　将高级语言翻译成计算机语言有编译，解释两种方式。两种方式只是翻译的时间不同。</p><p><strong>1.  编译型语言</strong></p><p>　　编译型语言写得程序在执行之前，需要借助一个程序，将高级语言编写的程序翻译成计算机能懂的机器语言，然后，这个机器语言就能直接执行了，也就是我们常见的（exe文件）。</p><p><strong>2.  解释型语言</strong></p><p>　　解释型语言的程序不需要编译，节省了一道工序，不过解释型的语言在运行的时候需要翻译，每个语句都是执行的时候才翻译，对比编译型语言，效率比较低。通俗来讲，就是借助一个程序，且这个程序能试图理解编写的代码，然后按照编写的代码中的要求执行。</p><p><strong>3.  脚本语言</strong></p><p>　　脚本语言也是一种解释型语言，又被称为扩建的语言，或者动态语言不需要编译，可以直接使用，由解释器来负责解释。</p><p>脚本语言一般都是以文本形式存在，类似于一种命令。</p><p><strong>4.  通俗理解编译型语言和解释型语言</strong></p><p>　　同行讨论编译型语言和解释型语言的时候，这么说过，编译型语言相当于做一桌子菜再吃，解释型语言就是吃火锅。解释型的语言执行效率低，类似火锅需要一边煮一边吃。</p><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="二面向对象">二、面向对象<a class="hash-link" href="#二面向对象" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="1-java的四个基本特性对多态的理解在项目中哪些地方用到多态">1. Java的四个基本特性，对多态的理解，在项目中哪些地方用到多态<a class="hash-link" href="#1-java的四个基本特性对多态的理解在项目中哪些地方用到多态" title="Direct link to heading">​</a></h3><ul><li><strong>Java的四个基本特性</strong><ul><li><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括<u>数据抽象</u>和<u>行为抽象</u>两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。  </li><li><strong>封装</strong>：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。 </li><li><strong>继承</strong>：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</li><li><strong>多态</strong>：多态性是指允许不同子类型的对象对同一消息作出不同的响应。 </li></ul></li><li><strong>多态的理解(多态的实现方式)</strong> <ul><li><strong>方法重载</strong>（overload）：实现的是<strong>编译时的多态性</strong>（也称为前绑定）。 </li><li><strong>方法重写</strong>（override）：实现的是<strong>运行时的多态性</strong>（也称为后绑定）。运行时的多态是面向对象最精髓的东西。 </li><li>要实现多态需要做两件事：<ul><li>1)  <strong>方法重写</strong>（子类继承父类并重写父类中已有的或抽象的方法）；</li><li>2)  <strong>对象造型</strong>（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 </li></ul></li></ul></li><li><strong>项目中对多态的应用</strong> <ul><li>举一个简单的例子，在物流信息管理系统中，有两种用户：订购客户和卖房客户，两个客户都可以登录系统，他们有相同的方法 Login，但登陆之后他们会进入到不同的页面，也就是在登录的时候会有不同的操作，两种客户都继承父类的 Login 方法，但对于不同的对象，拥有不同的操作。 </li></ul></li><li><strong>面相对象开发方式优点（B65）</strong><ul><li>较高的<strong>开发效率</strong>：可以把事物进行抽象，映射为开发的对象。</li><li>保证软件的<strong>鲁棒性</strong>：高重用性，可以重用已有的而且在相关领域经过长期测试的代码。</li><li>保证软件的<strong>高可维护性</strong>：代码的可读性非常好，设计模式也使得代码结构清晰，拓展性好。</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="2-什么是重载和重写">2. 什么是重载和重写<a class="hash-link" href="#2-什么是重载和重写" title="Direct link to heading">​</a></h3><ul><li><p><strong>重载</strong>：重载发生在同一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。 </p></li><li><p><strong>重写</strong>：重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。根据不同的子类对象确定调用的那个方法。 </p><div align="center"> <img loading="lazy" src="assets/overloading-vs-overriding.png" width="700" class="img_E7b_"></div></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="3-面向对象和面向过程的区别用面向过程可以实现面向对象吗">3. 面向对象和面向过程的区别？用面向过程可以实现面向对象吗？<a class="hash-link" href="#3-面向对象和面向过程的区别用面向过程可以实现面向对象吗" title="Direct link to heading">​</a></h3><ul><li>面向对象和面向过程的区别 <ul><li><strong>面向过程</strong>就像是一个细心的管家，事无具细的都要考虑到。而<strong>面向对象</strong>就像是个家用电器，你只需要知道他的功能，不需要知道它的工作原理。 </li><li><strong>面向过程</strong>是一种是“事件”为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这些步骤实现，并按顺序调用。<strong>面向对象</strong>是以“对象”为中心的编程思想。 </li><li>简单的举个例子：汽车发动、汽车到站 <ul><li>这对于 <strong>面向过程</strong> 来说，是两个事件，汽车启动是一个事件，汽车到站是另一个事件，<strong>面向过程</strong>编程的过程中我们关心的是事件，而不是汽车本身。针对上述两个事件，形成两个函数，之 后依次调用。（事件驱动，动词为主）</li><li>然而这对于<strong>面向对象</strong>来说，我们关心的是汽车这类对象，两个事件只是这类对象所具有的行为。而且对于这两个行为的顺序没有强制要求。（对象驱动，名词为主，将问题抽象出具体的对象，而这个对象有自己的属性和方法，在解决问题的时候是将不同的对象组合在一起使用）</li></ul></li></ul></li><li>用面向过程可以实现面向对象吗 ？<ul><li>如果是 C 语言来展现出面向对象的思想，C 语言中是不是有个叫结构体的东西，这个里面有自己定义的变量 可以通过函数指针就可以实现对象</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="4-面向对象开发的六个基本原则在项目中用过哪些原则">4. 面向对象开发的六个基本原则，在项目中用过哪些原则<a class="hash-link" href="#4-面向对象开发的六个基本原则在项目中用过哪些原则" title="Direct link to heading">​</a></h3><ul><li><p><strong>六个基本原则</strong>（参考《设计模式之禅》）</p><ul><li><p><strong>单一职责</strong>（Single Responsibility Principle 简称 SRP）：<strong>一个类应该仅有一个引起它变化的原因</strong>。在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。 </p></li><li><p><strong>里氏替换</strong>（Liskov Substitution Principle 简称 LSP）：<strong>任何时候子类型能够替换掉它们的父类型</strong>。子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。 </p></li><li><p><strong>依赖倒置</strong>（Dependence Inversion Principle 简称 DIP）：<strong>要依赖于抽象，不要依赖于具体类</strong>。要做到依赖倒置，应该做到：①高层模块不应该依赖底层模块，二者都应该依赖于抽象；②抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</p></li><li><p><strong>接口隔离</strong>（Interface Segregation Principle 简称 ISP）：<strong>不应该强迫客户依赖于他们不用的方法</strong> 。接口要小而专，绝不能大而全。臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。 </p></li><li><p><strong>最少知识原则</strong>（Least Knowledge Principle 简称 LKP）：<strong>只和你的朋友谈话</strong>。迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。 </p></li><li><p><strong>开闭原则</strong>（Open Closed Principle 简称 OCP）：<strong>软件实体应当对扩展开放，对修改关闭</strong>。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱。 </p></li></ul></li><li><p>其他原则</p><ul><li>合成聚和复用：优先使用聚合或合成关系复用代码</li><li>面向接口编程</li><li>优先使用组合，而非继承</li><li>一个类需要的数据应该隐藏在类的内部</li><li>类之间应该零耦合，或者只有传导耦合，换句话说，类之间要么没关系，要么只使用另一个类的接口提供的操作</li><li>在水平方向上尽可能统一地分布系统功能</li></ul></li></ul><ul><li>项目中用到的原则 <ul><li>单一职责、开放封闭、合成聚合复用(最简单的例子就是String类)、接口隔离</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="5-内部类有哪些">5. 内部类有哪些<a class="hash-link" href="#5-内部类有哪些" title="Direct link to heading">​</a></h3><p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。</p><p>在 Java 中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="一成员内部类">（一）成员内部类<a class="hash-link" href="#一成员内部类" title="Direct link to heading">​</a></h4><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以<strong>无限制的访问外围类的所有成员属性和方法，尽管是private的</strong>，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class OuterClass {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private String str;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public void outerDisplay(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;outerClass...&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public class InnerClass{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        public void innerDisplay(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            str = &quot;chenssy...&quot;; //使用外围内的属性</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            System.out.println(str);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            outerDisplay();  //使用外围内的方法</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public InnerClass getInnerClass(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return new InnerClass();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        OuterClass outer = new OuterClass();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        OuterClass.InnerClass inner = outer.getInnerClass();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        inner.innerDisplay();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">--------------------</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">chenssy...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">outerClass...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>在成员内部类中要注意两点：</p><ul><li><p>成员内部类中不能存在<code>static</code>方法, 但是可以存在<code>static</code>域, 前提是需要使用<code>final</code>关键字进行修饰.</p></li><li><p>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。   </p></li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="二局部内部类">（二）局部内部类<a class="hash-link" href="#二局部内部类" title="Direct link to heading">​</a></h4><p>有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。 </p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">//定义在方法里：</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Parcel5 {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public Destionation destionation(String str){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        class PDestionation implements Destionation{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            private String label;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            private PDestionation(String whereTo){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                label = whereTo;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            public String readLabel(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                return label;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return new PDestionation(str);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Parcel5 parcel5 = new Parcel5();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Destionation d = parcel5.destionation(&quot;chenssy&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//定义在作用域内:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Parcel6 {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private void internalTracking(boolean b){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if(b){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            class TrackingSlip{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                private String id;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                TrackingSlip(String s) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    id = s;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                String getSlip(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    return id;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            TrackingSlip ts = new TrackingSlip(&quot;chenssy&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            String string = ts.getSlip();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public void track(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        internalTracking(true);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Parcel6 parcel6 = new Parcel6();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        parcel6.track();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="三匿名内部类">（三）匿名内部类<a class="hash-link" href="#三匿名内部类" title="Direct link to heading">​</a></h4><p>匿名内部类也就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</p><p><strong>实例1：不使用匿名内部类来实现抽象方法</strong></p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">abstract class Person {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public abstract void eat();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Child extends Person {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public void eat() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;eat something&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Demo {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Person p = new Child();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        p.eat();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><strong>运行结果</strong>：eat something</p><p>可以看到，我们用 Child 继承了 Person 类，然后实现了 Child 的一个实例，将其向上转型为 Person 类的引用</p><p>但是，如果此处的 Child 类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？</p><p>这个时候就引入了匿名内部类</p><p><strong>实例2：匿名内部类的基本实现</strong></p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">abstract class Person {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public abstract void eat();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Demo {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Person p = new Person() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            public void eat() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                System.out.println(&quot;eat something&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        p.eat();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><strong>运行结果</strong>：eat something</p><p>可以看到，我们直接将抽象类 Person 中的方法在大括号中实现了，这样便可以省略一个类的书写，并且，匿名内部类还能用于接口上。</p><p><strong>实例3：在接口上使用匿名内部类</strong></p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">interface Person {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public void eat();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Demo {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Person p = new Person() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            public void eat() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                System.out.println(&quot;eat something&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        p.eat();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><strong>运行结果</strong>：eat something</p><p>由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p><p>最常用的情况就是在多线程的实现上，因为要实现多线程必须继承 Thread 类或是继承 Runnable 接口</p><p><strong>实例4：Thread类的匿名内部类实现</strong></p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Demo {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Thread t = new Thread() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                for (int i = 1; i &lt;= 5; i++) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    System.out.print(i + &quot; &quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        t.start();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><strong>运行结果</strong>：1 2 3 4 5</p><p><strong>实例5：Runnable接口的匿名内部类实现</strong></p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Demo {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Runnable r = new Runnable() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                for (int i = 1; i &lt;= 5; i++) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    System.out.print(i + &quot; &quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Thread t = new Thread(r);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        t.start();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><strong>运行结果</strong>：1 2 3 4 5</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="四静态内部类">（四）静态内部类<a class="hash-link" href="#四静态内部类" title="Direct link to heading">​</a></h4><p>关键字 static 中提到 static 可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用 static 修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。</p><ol><li><p>它的创建是不需要依赖于外围类的。</p></li><li><p>它不能使用任何外围类的非 static 成员变量和方法。</p></li></ol><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class OuterClass {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private String sex;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static String name = &quot;chenssy&quot;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 静态内部类 </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    static class InnerClass1{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // 在静态内部类中可以存在静态成员</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        public static String _name1 = &quot;chenssy_static&quot;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        public void display(){ </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            // 静态内部类只能访问外围类的静态成员变量和方法</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">           // 不能访问外围类的非静态成员变量和方法</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            System.out.println(&quot;OutClass name :&quot; + name);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 非静态内部类</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    class InnerClass2{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // 非静态内部类中不能存在静态成员</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        public String _name2 = &quot;chenssy_inner&quot;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        public void display(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            System.out.println(&quot;OuterClass name：&quot; + name);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 外围类方法</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public void display(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // 外围类访问静态内部类：内部类</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(InnerClass1._name1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // 静态内部类 可以直接创建实例不需要依赖于外围类</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        new InnerClass1().display();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // 非静态内部的创建需要依赖于外围类</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        // 方位非静态内部类的成员需要使用非静态内部类的实例</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(inner2._name2);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        inner2.display();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        OuterClass outer = new OuterClass();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        outer.display();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">----------------</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Output:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">chenssy_static</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">OutClass name :chenssy</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">chenssy_inner</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">OuterClass name：chenssy</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="6-组合继承和代理的区别">6. 组合、继承和代理的区别<a class="hash-link" href="#6-组合继承和代理的区别" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="定义">定义<a class="hash-link" href="#定义" title="Direct link to heading">​</a></h4><ul><li>组合：在新类中 new 另外一个类的对象，以添加该对象的特性。</li><li>继承：从基类继承得到子类，获得父类的特性。</li><li>代理：在代理类中创建某功能的类，调用类的一些方法以获得该类的部分特性。</li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="使用场合">使用场合<a class="hash-link" href="#使用场合" title="Direct link to heading">​</a></h4><ul><li><p>组合：各部件之间没什么关系，只需要组合即可。例如组装电脑，需要 new CPU(),new RAM(),new Disk()</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Computer {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public Computer() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        CPU cpu=new CPU();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        RAM ram=new RAM();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Disk disk=new Disk();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class CPU{    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class RAM{    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Disk{    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></li><li><p>继承：子类需要具有父类的功能，各子类之间有所差异。例如 Shape 类作为父类，子类有 Rectangle，CirCle，Triangle……代码不写了，大家都经常用。</p></li><li><p>代理：飞机控制类，我不想暴露太多飞机控制的功能，只需部分前进左右转的控制（而不需要暴露发射导弹功能）。通过在代理类中 new 一个飞机控制对象，然后在方法中添加飞机控制类的各个需要暴露的功能。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class PlaneDelegation{    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private PlaneControl planeControl;    //private外部不可访问</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 飞行员权限代理类，普通飞行员不可以开火</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    PlaneDelegation(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        planeControl = new PlaneControl();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public void speed(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        planeControl.speed();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public void left(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        planeControl.left();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public void right(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        planeControl.right();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">final class PlaneControl {// final表示不可继承，控制器都能继承那还得了</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    protected void speed() {}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    protected void fire() {}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    protected void left() {}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    protected void right() {}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></li></ul><p><strong>说明：</strong></p><ul><li>继承：代码复用，引用不灵活；</li><li>组合：代码复用，</li><li>接口：引用灵活； </li><li>推荐组合+接口使用，看 IO 中包装流 FilterInputStream 中的策略模式</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="7-什么是构造函数">7. 什么是构造函数<a class="hash-link" href="#7-什么是构造函数" title="Direct link to heading">​</a></h3><p>构造函数是函数的一种特殊形式。特殊在哪里？构造函数中不需要定义返回类型（void 是无需返回值的意思，请注意区分两者），且构造函数的名称与所在的类名完全一致，其余的与函数的特性相同，可以带有参数列表，可以存在函数的重载现象。 </p><p>一般用来初始化一些成员变量，当要生成一个类的对象（实例）的时候就会调用类的构造函数。如果不显示声明类的构造方法，会自动生成一个默认的不带参数的空的构造函数。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Demo{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int num=0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //无参构造函数</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Demo()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;constractor_run&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //有参构造函数</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Demo(int num)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;constractor_args_run&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //普通成员函数</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public void demoFunction()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;function_run&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>在这里要说明一点，如果在类中我们不声明构造函数，JVM 会帮我们默认生成一个空参数的构造函数；如果在类中我们声明了带参数列表的构造函数，JVM 就不会帮我们默认生成一个空参数的构造函数，我们想要使用空参数的构造函数就必须自己去显式的声明一个空参的构造函数。 </p><p><strong>构造函数的作用</strong></p><p>　　通过开头的介绍，构造函数的轮廓已经渐渐清晰，那么为什么会有构造函数呢？构造函数有什么作用？构造函数是面向对象编程思想所需求的，它的主要作用有以下两个：</p><ul><li><strong>创建对象</strong>。任何一个对象创建时，都需要初始化才能使用，所以任何类想要创建实例对象就必须具有构造函数。</li><li><strong>对象初始化</strong>。构造函数可以对对象进行初始化，并且是给与之格式（参数列表）相符合的对象初始化，是具有一定针对性的初始化函数。</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="8-向上造型和向下造型">8. 向上造型和向下造型<a class="hash-link" href="#8-向上造型和向下造型" title="Direct link to heading">​</a></h3><p>父类引用能指向子类对象，子类引用不能指向父类对象；</p><p><strong>向上造型</strong></p><p>父类引用指向子类对象，例如：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Father f1 = new Son();</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><strong>向下造型</strong></p><p>把指向子类对象的父类引用赋给子类引用，需要强制转换，例如：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Father f1 = new Son();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Son s1 = (Son)f1;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>但有运行出错的情况：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Father f2 = new Father();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Son s2 = (Son)f2; //编译无错但运行会出现错误</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>在不确定父类引用是否指向子类对象时，可以用 instanceof 来判断：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">if(f3 instanceof Son){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     Son s3 = (Son)f3;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="三关键字">三、关键字<a class="hash-link" href="#三关键字" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="1-final与static的区别">1. final与static的区别<a class="hash-link" href="#1-final与static的区别" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="final">final<a class="hash-link" href="#final" title="Direct link to heading">​</a></h4><ul><li><p><strong>1. 数据</strong></p><ul><li><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p></li><li><p>对于基本类型，final 使数值不变；</p></li><li><p>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</p></li></ul></li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">final int x = 1;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">final A y = new A();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">y.a = 1;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li><p><strong>2. 方法</strong></p><ul><li>声明方法不能被子类覆盖。<ul><li>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是覆盖基类方法，而是在子类中定义了一个新的方法。</li></ul></li></ul></li><li><p><strong>3. 类</strong></p><ul><li>声明类不允许被继承。</li></ul></li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="static">static<a class="hash-link" href="#static" title="Direct link to heading">​</a></h4><ul><li><p><strong>1. 静态变量</strong></p><p>   静态变量在内存中只存在一份，只在类初始化时赋值一次。</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain"> - 静态变量：类所有的实例都共享静态变量，可以直接通过类名来访问它；</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> - 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class A {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int x;        // 实例变量</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static int y;  // 静态变量</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>　　注意：不能再成员函数内部定义static变量。</p><ul><li><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。</p></li><li><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p></li><li><p><strong>4. 静态内部类</strong></p><p>内部类的一种，静态内部类不依赖外部类，且不能访问外部类的非静态的变量和方法。</p></li><li><p><strong>5. 静态导包</strong> </p></li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">import static com.xxx.ClassName.*</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>　　在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><ul><li><p><strong>6. 变量赋值顺序</strong> </p><p>静态变量的赋值和静态语句块的运行优先于实例变量的赋值和普通语句块的运行，静态变量的赋值和静态语句块的运行哪个先执行取决于它们在代码中的顺序。</p></li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static String staticField = &quot;静态变量&quot;;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">static {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(&quot;静态语句块&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public String field = &quot;实例变量&quot;;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(&quot;普通语句块&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>最后才运行构造函数</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public InitialOrderTest() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(&quot;构造函数&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="2-breakcontinuereturn">2. break、continue、return<a class="hash-link" href="#2-breakcontinuereturn" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="break">break<a class="hash-link" href="#break" title="Direct link to heading">​</a></h4><p>跳出当前循环；但是如果是嵌套循环，则只能跳出当前的这一层循环，只有逐层 break 才能跳出所有循环。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">for (int i = 0; i &lt; 10; i++) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // 在执行i==6时强制终止循环，i==6不会被执行</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (i == 6)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(i);  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">输出结果为0 1 2 3 4 5 ；6以后的都不会输出</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="continue">continue<a class="hash-link" href="#continue" title="Direct link to heading">​</a></h4><p>终止当前循环，但是不跳出循环（在循环中 continue 后面的语句是不会执行了），继续往下根据循环条件执行循环。 </p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">for (int i = 0; i &lt; 10; i++) {  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // i==6不会被执行，而是被中断了    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (i == 6)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        continue;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(i);  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">输出结果为0 1 2 3 4 5 7 8 9； 只有6没有输出</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="return">return<a class="hash-link" href="#return" title="Direct link to heading">​</a></h4><ul><li>return 从当前的方法中退出，返回到该调用的方法的语句处，继续执行。 </li><li>return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致。 </li><li>return 后面也可以不带参数，不带参数就是返回空，其实主要目的就是用于想中断函数执行，返回调用函数处。</li></ul><p>特别注意：返回值为 void 的方法，从某个判断中跳出，必须用 return。</p><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="3-finalfinally和finalize区别">3. final、finally和finalize区别<a class="hash-link" href="#3-finalfinally和finalize区别" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="final-1">final<a class="hash-link" href="#final-1" title="Direct link to heading">​</a></h4><p>final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承。</p><ul><li>final 属性：被final修饰的变量不可变（引用不可变）</li><li>final 方法：不允许任何子类重写这个方法，但子类仍然可以使用这个方法</li><li>final 参数：用来表示这个参数在这个函数内部不允许被修改</li><li>final 类：此类不能被继承，所有方法都不能被重写</li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="finally">finally<a class="hash-link" href="#finally" title="Direct link to heading">​</a></h4><p>　　在异常处理的时候，提供 finally 块来执行任何的清除操作。如果抛出一个异常，那么相匹配的 catch 字句就会执行，然后控制就会进入 finally 块，前提是有 finally 块。例如：数据库连接关闭操作上</p><p>　　finally 作为异常处理的一部分，它只能用在 try/catch 语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。（×）（<strong>这句话其实存在一定的问题，还没有深入了解，欢迎大家在 issue 中提出自己的见解）</strong> </p><ul><li>异常情况说明：<ul><li>在执行 try 语句块之前已经返回或抛出异常，所以 try 对应的 finally 语句并没有执行。 </li><li>我们在 try 语句块中执行了 System.exit (0) 语句，终止了 Java 虚拟机的运行。那有人说了，在一般的 Java 应用中基本上是不会调用这个 System.exit(0) 方法的 </li><li>当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行 </li><li>还有更极端的情况，就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。可能有人认为死机、断电这些理由有些强词夺理，没有关系，我们只是为了说明这个问题。 </li></ul></li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="finalize">finalize<a class="hash-link" href="#finalize" title="Direct link to heading">​</a></h4><p>　　finalize() 是 Object 中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它 finalize() 方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。要明白这个问题，先看一下虚拟机是如何判断一个对象该死的。</p><p>　　可以覆盖此方法来实现对其他资源的回收，例如关闭文件。</p><h5 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="判定死亡">判定死亡<a class="hash-link" href="#判定死亡" title="Direct link to heading">​</a></h5><p>　　Java 采用可达性分析算法来判定一个对象是否死期已到。Java中以一系列 &quot;GC  Roots&quot; 对象作为起点，如果一个对象的引用链可以最终追溯到 &quot;GC  Roots&quot; 对象，那就天下太平。</p><p>　　否则如果只是A对象引用B，B对象又引用A，A B引用链均未能达到 &quot;GC  Roots&quot; 的话，那它俩将会被虚拟机宣判符合死亡条件，具有被垃圾回收器回收的资格。</p><h5 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="最后的救赎">最后的救赎<a class="hash-link" href="#最后的救赎" title="Direct link to heading">​</a></h5><p>上面提到了判断死亡的依据，但被判断死亡后，还有生还的机会。</p><p>如何自我救赎：</p><ol><li><p>对象覆写了 finalize() 方法（这样在被判死后才会调用此方法，才有机会做最后的救赎）；</p></li><li><p>在 finalize() 方法中重新引用到 &quot;GC  Roots&quot; 链上（如把当前对象的引用 this 赋值给某对象的类变量/成员变量，重新建立可达的引用）.</p></li></ol><p>需要注意：</p><p>　　finalize() 只会在对象内存回收前被调用一次 (The finalize method is never invoked more than once by a Java virtual machine for any given object. )</p><p>　　finalize() 的调用具有不确定性，只保证方法会调用，但不保证方法里的任务会被执行完（比如一个对象手脚不够利索，磨磨叽叽，还在自救的过程中，被杀死回收了）。</p><h5 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="finalize的作用">finalize()的作用<a class="hash-link" href="#finalize的作用" title="Direct link to heading">​</a></h5><p>　　虽然以上以对象救赎举例，但 finalize() 的作用往往被认为是用来做最后的资源回收。
　　基于在自我救赎中的表现来看，此方法有很大的不确定性（不保证方法中的任务执行完）而且运行代价较高。所以用来回收资源也不会有什么好的表现。</p><p>　　综上：finalize() 方法并没有什么鸟用。</p><p>　　至于为什么会存在一个鸡肋的方法：书中说 “它不是 C/C++ 中的析构函数，而是 Java 刚诞生时为了使 C/C++ 程序员更容易接受它所做出的一个妥协”。</p><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/L_wwbs/article/details/70770447?locationNum=1&amp;fps=1" target="_blank" rel="noopener noreferrer">关于finalize() - CSDN博客</a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="4-assert有什么作用">4. assert有什么作用<a class="hash-link" href="#4-assert有什么作用" title="Direct link to heading">​</a></h3><p>　　断言（assert）作为一种软件调试的方法，提供了一种在代码中进行正确性检查的机制，目前很多开发语言都支持这种机制。</p><p>　　在实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确的状态下，系统将给出警告并且退出。一般来说，assertion 用于保证程序最基本、关键的正确性。<strong>assertion 检查通常在开发和测试时开启</strong>。为了提高性能，<strong>在软件发布后，assertion 检查通常是关闭的</strong>。下面简单介绍一下 Java 中 assertion 的实现。</p><p>　　在语法上，为了支持 assertion，Java 增加了一个关键字 assert。它包括两种表达式，分别如下：</p><p>　　<strong>assert &lt;boolean表达式&gt;</strong></p><p>　　如果 &lt;boolean表达式&gt; 为 true，则程序继续执行。</p><p>　　如果为 false，则程序抛出 AssertionError，并终止执行。</p><p>　　<strong>assert &lt;boolean表达式&gt; : &lt;错误信息表达式&gt;</strong></p><p>　　如果 &lt;boolean表达式&gt; 为 true，则程序继续执行。</p><p>　　如果为 false，则程序抛出 java.lang.AssertionError，并输入&lt;错误信息表达式&gt;。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(&quot;123&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int a = 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int b = 1;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    assert a == b; //需显示开启，默认为不开启状态 </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    assert a == b : &quot;执行失败！&quot;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(&quot;1234&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>assert 的应用范围很多，主要包括：</p><ul><li>检查控制流</li><li>检查输入参数是否有效</li><li>检查函数结果是否有效</li><li>检查程序不变</li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="什么是断言">什么是断言<a class="hash-link" href="#什么是断言" title="Direct link to heading">​</a></h4><blockquote><p>断言是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真，可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。同样，程序投入运行后，最终用户在遇到问题时可以重新启用断言。</p></blockquote><p>使用断言可以创建更稳定、品质更好且 不易于出错的代码。当需要在一个值为 <code>false</code> 时中断当前操作的话，可以使用断言。单元测试必须使用断言（Junit/JunitX）。</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="常用断言方法">常用断言方法<a class="hash-link" href="#常用断言方法" title="Direct link to heading">​</a></h4><table><thead><tr><th>断言</th><th>描述</th></tr></thead><tbody><tr><td>void assertEquals(<!-- -->[String message]<!-- -->, expected value, actual value)</td><td>断言两个值相等。值可能是类型有 int, short, long, byte, char or java.lang.Object. 第一个参数是一个可选的字符串消息</td></tr><tr><td>void assertTrue(<!-- -->[String message]<!-- -->, boolean condition)</td><td>断言一个条件为真</td></tr><tr><td>void assertFalse(<!-- -->[String message]<!-- -->,boolean condition)</td><td>断言一个条件为假</td></tr><tr><td>void assertNotNull(<!-- -->[String message]<!-- -->, java.lang.Object object)</td><td>断言一个对象不为空(null)</td></tr><tr><td>void assertNull(<!-- -->[String message]<!-- -->, java.lang.Object object)</td><td>断言一个对象为空(null)</td></tr><tr><td>void assertSame(<!-- -->[String message]<!-- -->, java.lang.Object expected, java.lang.Object actual)</td><td>断言，两个对象引用相同的对象</td></tr><tr><td>void assertNotSame(<!-- -->[String message]<!-- -->, java.lang.Object unexpected, java.lang.Object actual)</td><td>断言，两个对象不是引用同一个对象</td></tr><tr><td>void assertArrayEquals(<!-- -->[String message]<!-- -->, expectedArray, resultArray)</td><td>断言预期数组和结果数组相等。数组的类型可能是 int, long, short, char, byte or java.lang.Object.</td></tr></tbody></table><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="5-volatile">5. volatile<a class="hash-link" href="#5-volatile" title="Direct link to heading">​</a></h3><blockquote><p>每次都读错，美式发音：volatile /&#x27;vɑlətl/ adj. <!-- -->[化学]<!-- --> 挥发性的；不稳定的；爆炸性的；反复无常的 </p></blockquote><p>　　volatile 是一个<strong>类型修饰符</strong>（type specifier），它是被设计用来修饰被不同线程访问和修改的变量。在使用 volatile 修饰成员变量后，所有线程在任何时间所看到变量的值都是相同的。此外，使用 volatile 会组织编译器对代码的优化，因此会降低程序的执行效率。所以，除非迫不得已，否则，能不使用 volatile 就尽量不要使用 volatile。</p><ul><li><p>每次访问变量时，总是获取主内存的最新值</p></li><li><p>每次修改变量后，立刻写回到主内存中</p><div align="center"> <img loading="lazy" src="assets/java-volatile.png" width="400" class="img_E7b_"></div></li></ul><p>参考资料：</p><ul><li><a href="https://segmentfault.com/a/1190000015087945" target="_blank" rel="noopener noreferrer">理解java Volatile 关键字 - 个人文章 - SegmentFault 思否</a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="6-instanceof">6. instanceof<a class="hash-link" href="#6-instanceof" title="Direct link to heading">​</a></h3><p>instanceof 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。</p><p>instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Object testObject = new ArrayList();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        displayObjectClass(testObject);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void displayObjectClass(Object o) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if (o instanceof Vector)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            System.out.println(&quot;对象是 java.util.Vector 类的实例&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        else if (o instanceof ArrayList)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            System.out.println(&quot;对象是 java.util.ArrayList 类的实例&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            System.out.println(&quot;对象是 &quot; + o.getClass() + &quot; 类的实例&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="7-strictfp">7. strictfp<a class="hash-link" href="#7-strictfp" title="Direct link to heading">​</a></h3><p>strictfp，即 <strong>strict float point</strong> (精确浮点)。 </p><p>strictfp 关键字可应用于类、接口或方法。使用 strictfp 关键字声明一个方法时，该方法中所有的 float 和 double 表达式都严格遵守 FP-strict 的限制,符合 IEEE-754 规范。当对一个类或接口使用 strictfp 关键字时，该类中的所有代码，包括嵌套类型中的初始设定值和代码，都将严格地进行计算。严格约束意味着所有表达式的结果都必须是 IEEE 754 算法对操作数预期的结果，以单精度和双精度格式表示。</p><p>如果你想让你的浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，可以用关键字strictfp.</p><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="8-transient">8. transient<a class="hash-link" href="#8-transient" title="Direct link to heading">​</a></h3><blockquote><p>transient 英 /&#x27;trænzɪənt/   adj. 短暂的；路过的  n. 瞬变现象；过往旅客；候鸟</p></blockquote><p>我们都知道一个对象只要实现了 Serilizable 接口，这个对象就可以被序列化，Java 的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了 Serilizable 接口，这个类的所有属性和方法都会自动序列化。</p><p>然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上 transient 关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><p><strong>总之，Java 的 transient 关键字为我们提供了便利，你只需要实现 Serilizable 接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</strong></p><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="noopener noreferrer">Java transient关键字使用小记 - Alexia(minmin) - 博客园</a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="9-native">9. native<a class="hash-link" href="#9-native" title="Direct link to heading">​</a></h3><p>native（即 JNI，Java Native Interface），凡是一种语言，都希望是纯。比如解决某一个方案都喜欢就单单这个语言来写即可。Java 平台有个用户和本地 C 代码进行互操作的 API，称为 Java Native Interface (Java本地接口)。 </p><div align="center"> <img loading="lazy" src="assets/java-native-interface.png" width="500" class="img_E7b_"></div><br><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/b3051/p/7484501.html" target="_blank" rel="noopener noreferrer">java中native的用法 - 不止吧 - 博客园</a></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="四基本数据类型与运算">四、基本数据类型与运算<a class="hash-link" href="#四基本数据类型与运算" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="1-java的基本数据类型和引用类型自动装箱和拆箱">1. Java的基本数据类型和引用类型，自动装箱和拆箱<a class="hash-link" href="#1-java的基本数据类型和引用类型自动装箱和拆箱" title="Direct link to heading">​</a></h3><ul><li>4 类 8 种基本数据类型。4 整数型，2 浮点型，1 布尔型，1 字符型</li></ul><table><thead><tr><th>类型</th><th>存储</th><th>取值范围</th><th>默认值</th><th>包装类</th></tr></thead><tbody><tr><td><strong>整数型</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>byte</td><td>8</td><td>最大存储数据量是 255，最小 -2<sup>7</sup>，最大 2<sup>7</sup>-1，<br>[-128~127]</td><td>(byte) 0</td><td>Byte</td></tr><tr><td>short</td><td>16</td><td>最大数据存储量是 65536，<!-- -->[-2<sup>15</sup>,2<sup>15</sup>-1]<!-- -->，<br>[-32768,32767]<!-- -->，±3万</td><td>(short) 0</td><td>Short</td></tr><tr><td>int</td><td>32</td><td>最大数据存储容量是 2<sup>31</sup>-1，<br>[-2<sup>31</sup>,2<sup>31</sup>-1]<!-- -->，±21亿，<!-- -->[ -2147483648, 2147483647]</td><td>0</td><td>Integer</td></tr><tr><td>long</td><td>64</td><td>最大数据存储容量是 2<sup>64</sup>-1，<br>[-2<sup>63</sup>,2<sup>63</sup>-1]<!-- -->， ±922亿亿（±（922+16个零））</td><td>0L</td><td>Long</td></tr><tr><td><strong>浮点型</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>float</td><td>32</td><td>数据范围在 3.4e-45~1.4e38，直接赋值时必须在数字后加上 f 或 F</td><td>0.0f</td><td>Float</td></tr><tr><td>double</td><td>64</td><td>数据范围在 4.9e-324~1.8e308，赋值时可以加 d 或 D 也可以不加</td><td>0.0d</td><td>Double</td></tr><tr><td><strong>布尔型</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>boolean</td><td>1</td><td>true / flase</td><td>false</td><td>Boolean</td></tr><tr><td><strong>字符型</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>char</td><td>16</td><td>存储 Unicode 码，用单引号赋值</td><td>&#x27;\u0000&#x27; (null)</td><td>Character</td></tr></tbody></table><ul><li>引用数据类型<ul><li>类（class）、接口（interface）、数组</li></ul></li><li>自动装箱和拆箱<ul><li>基本数据类型和它对应的封装类型之间可以相互转换。自动拆装箱是 <code>jdk5.0</code> 提供的新特特性，它可以自动实现类型的转换</li><li><strong>装箱</strong>：从<strong>基本数据类型</strong>到<strong>封装类型</strong>叫做装箱</li><li><strong>拆箱</strong>：从<strong>封装类型</strong>到<strong>基本数据类型</strong>叫拆箱</li></ul></li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// jdk 1.5</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class TestDemo {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Integer m =10;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        int i = m;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>　　上面的代码在 jdk1.4 以后的版本都不会报错，它实现了自动拆装箱的功能，如果是 jdk1.4，就得这样写了</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// jdk 1.4</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class TestDemo {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Integer b = new Integer(210);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        int c = b.intValue();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="2-valueof缓存池">2. ValueOf缓存池<a class="hash-link" href="#2-valueof缓存池" title="Direct link to heading">​</a></h3><p>　　new Integer(123)  与 Integer.valueOf(123)  的区别在于，new Integer(123)  每次都会新建一个对象，而 Integer.valueOf(123)  可能会使用缓存对象，因此多次使用 Integer.valueOf(123)  会取得同一个对象的引用。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Integer x = new Integer(123);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Integer y = new Integer(123);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(x == y);    // false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Integer z = Integer.valueOf(123);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Integer k = Integer.valueOf(123);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(z == k);   // true</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>　　编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Integer m = 123;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Integer n = 123;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(m == n); // true</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接使用缓存池的内容。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// valueOf 源码实现</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static Integer valueOf(int i) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return new Integer(i);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>在 Java 8 中，Integer 缓存池的大小默认为 -128<!-- -->~<!-- -->127。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">static final int low = -128;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">static final int high;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">static final Integer cache[];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">static {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // high value may be configured by property</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int h = 127;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    String integerCacheHighPropValue =</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (integerCacheHighPropValue != null) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            int i = parseInt(integerCacheHighPropValue);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            i = Math.max(i, 127);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            // Maximum array size is Integer.MAX_VALUE</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        } catch( NumberFormatException nfe) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            // If the property cannot be parsed into an int, ignore it.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    high = h;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cache = new Integer[(high - low) + 1];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int j = low;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    for(int k = 0; k &lt; cache.length; k++)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cache[k] = new Integer(j++);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // range [-128, 127] must be interned (JLS7 5.1.7)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    assert IntegerCache.high &gt;= 127;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><p>参考资料：</p><ul><li><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" target="_blank" rel="noopener noreferrer">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123</a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="3-i和i有什么区别">3. i++和++i有什么区别<a class="hash-link" href="#3-i和i有什么区别" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="i">i++<a class="hash-link" href="#i" title="Direct link to heading">​</a></h4><p>i++ 是在程序执行完毕后进行自增，而 ++i 是在程序开始执行前进行自增。</p><p><strong>i++ 的操作分三步</strong></p><ol><li>栈中取出 i</li><li>i 自增 1</li><li>将 i 存到栈</li></ol><p>三个阶段：内存到寄存器，寄存器自增，写回内存（这三个阶段中间都可以被中断分离开）</p><p>所以 i++ 不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致 i 的值不正确自增</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="i-1">++i<a class="hash-link" href="#i-1" title="Direct link to heading">​</a></h4><p>在多核的机器上，CPU 在读取内存 i 时也会可能发生同时读取到同一值，这就导致两次自增，实际只增加了一次。</p><p>i++ 和 ++i 都不是原子操作</p><p><strong>原子性</strong>：指的是一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程打断。</p><p>JMM 三大特性：原子性，可见性，有序性。详情请阅读 Github 仓库：<a href="/docs/backend/java/Java并发编程">Java 并发编程</a> 一文。</p><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="4-位运算符">4. 位运算符<a class="hash-link" href="#4-位运算符" title="Direct link to heading">​</a></h3><p>Java 定义了位运算符，应用于整数类型 (int)，长整型 (long)，短整型 (short)，字符型 (char)，和字节型 (byte)等类型。</p><p>下表列出了位运算符的基本运算，假设整数变量A的值为60和变量B的值为13</p><p>A（60）：0011 1100</p><p>B（13）：0000 1101</p><table><thead><tr><th>操作符</th><th>名称</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>＆</td><td>与</td><td>如果相对应位都是 1，则结果为 1，否则为 0</td><td>（A＆B）得到 12，即 0000 1100</td></tr><tr><td>|</td><td>或</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（A<!-- -->|<!-- -->B）得到 61，即 0011 1101</td></tr><tr><td>^</td><td>异或</td><td>如果相对应位值相同，则结果为 0，否则为 1</td><td>（A^B）得到49，即 0011 0001</td></tr><tr><td>〜</td><td>非</td><td>按位取反运算符翻转操作数的每一位，即 0 变成 1，1 变成 0</td><td>（〜A）得到-61，即1100 0011</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>（左移一位乘2）按位左移运算符。左操作数按位左移右操作数指定的位数。左移 n 位表示原来的值乘 2<sup>n</sup></td><td>A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td>&gt;&gt;</td><td></td><td>（右移一位除2）有符号右移，按位右移运算符。左操作数按位右移右操作数指定的位数</td><td>A &gt;&gt; 2得到15即 1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>无符号右移</td><td>无符号右移，按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td><td>A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="5-原码补码反码是什么">5. 原码、补码、反码是什么<a class="hash-link" href="#5-原码补码反码是什么" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="机器数">机器数<a class="hash-link" href="#机器数" title="Direct link to heading">​</a></h4><p>　　一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为 0，负数为 1。</p><p>　　比如，十进制中的数 +3 ，计算机字长为 8 位，转换成二进制就是 00000011。如果是 -3 ，就是 10000011 。那么，这里的 00000011 和 10000011 就是机器数。</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="真值">真值<a class="hash-link" href="#真值" title="Direct link to heading">​</a></h4><p>　　因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位 1 代表负，其真正数值是 -3 而不是形式值 131（10000011 转换成十进制等于 131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>例：0000 0001 的真值 = +000 0001 = +1，1000 0001 的真值 = –000 0001 = –1</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="原码">原码<a class="hash-link" href="#原码" title="Direct link to heading">​</a></h4><p>　　原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是 8 位二进制:</p><p>　　<!-- -->[+1]<sub>原</sub> = 0000 0001</p><p>　　<!-- -->[-1]<sub>原</sub> = 1000 0001</p><p>　　第一位是符号位。因为第一位是符号位，所以 8 位二进制数的取值范围就是：<!-- -->[1111 1111 , 0111 1111]<!-- -->，即：<!-- -->[-127 , 127]</p><p>　　原码是人脑最容易理解和计算的表示方式</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="反码">反码<a class="hash-link" href="#反码" title="Direct link to heading">​</a></h4><p>反码的表示方法是：</p><ul><li><strong>正数</strong>的反码是其本身；</li><li><strong>负数</strong>的反码是在其原码的基础上，<strong>符号位不变，其余各个位取反</strong>。</li></ul><p>[+1]<!-- --> = <!-- -->[00000001]<sub>原</sub> = <!-- -->[00000001]<sub>反</sub></p><p>[-1]<!-- --> = <!-- -->[10000001]<sub>原</sub>= <!-- -->[11111110]<sub>反</sub></p><p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算。</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="补码">补码<a class="hash-link" href="#补码" title="Direct link to heading">​</a></h4><p>补码的表示方法是：</p><ul><li><strong>正数</strong>的补码就是其本身；</li><li><strong>负数</strong>的补码是在其原码的基础上，符号位不变，其余各位取反, 最后+1。(<strong>反码的基础上 +1</strong>)</li></ul><p>[+1]<!-- --> = <!-- -->[0000 0001]<sub>原</sub> = <!-- -->[0000 0001]<sub>反</sub> = <!-- -->[0000 0001]<sub>补</sub></p><p>[-1]<!-- -->  = <!-- -->[1000 0001]<sub>原</sub> = <!-- -->[1111 1110]<sub>反</sub> = <!-- -->[1111 1111]<sub>补</sub></p><p>对于负数，补码表示方式也是人脑无法直观看出其数值的。 通常也需要转换成原码在计算其数值。</p><p>参考资料：</p><ul><li><a href="http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener noreferrer">原码, 反码, 补码 详解 - ziqiu.zhang - 博客园</a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="6-不用额外变量交换两个整数的值">6. 不用额外变量交换两个整数的值<a class="hash-link" href="#6-不用额外变量交换两个整数的值" title="Direct link to heading">​</a></h3><p>如果给定整数 a 和 b，用以下三行代码即可交换 a 和b 的值</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">a = a ^ b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">b = a ^ b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">a = a ^ b;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>假设 a 异或 b 的结果记为 c，<strong>c 就是 a 整数位信息和 b 整数位信息的所有不同信息</strong>。<ul><li>比如：a = 4 = 100，b = 3 = 011，a^b = c = 111</li></ul></li><li>a 异或 c 的结果就是 b，比如：a = 4 = 100，c = 111，a^c = 011 = 3 = b</li><li>b 异或c 的结果就是 a，比如：b = 3 = 011，c = 111，b^c = 100 = 4 = a</li></ul><p>说明：位运算的题目基本上都带有靠经验积累才会做的特征，也就是准备阶段需要做足够多的题，面试时才会有良好的感觉。</p><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="7-不使用运算符进行ab操作">7. 不使用运算符进行a+b操作<a class="hash-link" href="#7-不使用运算符进行ab操作" title="Direct link to heading">​</a></h3><ul><li>a^b;  得到不含进位之和</li><li>(a &amp; b)&lt;&lt;1;  进位</li><li>只要进位不为零，则迭代；否则返回</li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int add(int a, int b)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int c = a &amp; b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int r = a ^ b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if(c == 0){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return r;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    else{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return add(r, c &lt;&lt; 1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main(int argn, char *argv[])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;sum = %d\n&quot;, add(-10000, 56789));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="8-和-和的区别">8. &amp;和&amp;&amp; 、|和||的区别<a class="hash-link" href="#8-和-和的区别" title="Direct link to heading">​</a></h3><p>（1）&amp;&amp; 和 &amp; 都是表示与，区别是 &amp;&amp; 只要第一个条件不满足，后面条件就不再判断。而 &amp; 要对所有的条件都进行判断。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 例如：</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main(String[] args) {  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if((23!=23) &amp;&amp; (100/0==0)){  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;运算没有问题。&quot;);  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }else{  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;没有报错&quot;);  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 输出的是“没有报错”。而将 &amp;&amp; 改为 &amp; 就会如下错误：</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li><p>原因：</p><ul><li><p>&amp;&amp;时判断第一个条件为 false，后面的 100/0==0 这个条件就没有进行判断。</p></li><li><p>&amp; 时要对所有的条件进行判断，所以会对后面的条件进行判断，所以会报错。</p></li></ul></li></ul><p>  （2）|| 和 | 都是表示 “或”，区别是 || 只要满足第一个条件，后面的条件就不再判断，而 | 要对所有的条件进行判断。 看下面的程序： </p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main(String[] args) {  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if((23==23)||(100/0==0)){  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;运算没有问题。&quot;);  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }else{  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(&quot;没有报错&quot;);  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 此时输出“运算没有问题”。若将||改为|则会报错。</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ul><li>原因<ul><li>|| 判断第一个条件为 true，后面的条件就没有进行判断就执行了括号中的代码</li><li>而 | 要对所有的条件进行判断，所以会报错</li></ul></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="五字符串与数组">五、字符串与数组<a class="hash-link" href="#五字符串与数组" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="1-stringstringbufferstringbuilder以及对string不变性的理解">1. String,StringBuffer,StringBuilder，以及对String不变性的理解<a class="hash-link" href="#1-stringstringbufferstringbuilder以及对string不变性的理解" title="Direct link to heading">​</a></h3><ul><li>String、StringBuffer、StringBuilder <ul><li>都是 final 类，都不允许被继承</li><li>String 长度是不可变的，StringBuffer、StringBuilder 长度是可变的</li><li>StringBuffer 是线程安全的，StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer 在 StringBuilder 的方法之上添加了 synchronized 修饰，保证线程安全</li><li>StringBuilder 比 StringBuffer 拥有更好的性能</li><li>如果一个 String 类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时 String 的速度比 StringBuffer 和 StringBuilder 的性能好的多</li></ul></li></ul><ul><li>String 不变性的理解 <ul><li>String 类是被 final 进行修饰的，不能被继承 </li><li>在用 + 号链接字符串的时候会创建新的字符串</li><li>String s = new String(&quot;Hello world&quot;); 可能创建两个对象也可能创建一个对象。如果静态区中有 “Hello world” 字符串常量对象的话，则仅仅在堆中创建一个对象。如果静态区中没有 “Hello world” 对象，则堆上和静态区中都需要创建对象。 </li><li>在 Java 中, 通过使用 &quot;+&quot; 符号来串联字符串的时候,，实际上底层会转成通过 StringBuilder 实例的 append() 方法来实现。</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="2-string有重写object的hashcode和tostring吗如果重写equals不重写hashcode会出现什么问题">2. String有重写Object的hashcode和toString吗？如果重写equals不重写hashcode会出现什么问题？<a class="hash-link" href="#2-string有重写object的hashcode和tostring吗如果重写equals不重写hashcode会出现什么问题" title="Direct link to heading">​</a></h3><ul><li><p>String 有重写 Object 的 hashcode 和 toString吗？ </p><ul><li>String 重写了 Object 类的 hashcode 和 toString 方法。 </li></ul></li><li><p>当 equals 方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相对等的两个对象必须有相同的 hashCode </p><ul><li>object1.equals(object2) 时为 true， object1.hashCode() ==  object2.hashCode() 为 true </li><li>object1.hashCode() ==  object2.hashCode() 为 false 时，object1.equals(object2) 必定为 false </li><li>object1.hashCode() ==  object2.hashCode() 为 true时，但 object1.equals(object2) 不一定定为 true </li></ul></li><li><p>重写 equals 不重写 hashcode 会出现什么问题 </p><ul><li>在存储散列集合时(如 Set 类)，如果原对象.equals(新对象)，但没有对 hashCode 重写，即两个对象拥有不同的 hashCode，则在集合中将会存储两个值相同的对象，从而导致混淆。因此在重写 equals 方法时，必须重写 hashCode 方法。 </li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="3-如果你定义一个类包括学号姓名分数如何把这个对象作为key要重写equals和hashcode吗">3. 如果你定义一个类，包括学号，姓名，分数，如何把这个对象作为key？要重写equals和hashcode吗<a class="hash-link" href="#3-如果你定义一个类包括学号姓名分数如何把这个对象作为key要重写equals和hashcode吗" title="Direct link to heading">​</a></h3><ul><li>需要重写 equals 方法和 hashcode，必须保证对象的属性改变时，其 hashcode 不能改变。 </li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="4-字面量">4. 字面量<a class="hash-link" href="#4-字面量" title="Direct link to heading">​</a></h3><p>在编程语言中，字面量（literal）指的是在源代码中直接表示的一个固定的值。 </p><p>八进制是用在整数字面量之前添加 “0” 来表示的。 </p><p>十六进制用在整数字面量之前添加 “0x” 或者 “0X” 来表示的</p><p> Java 7 中新增了二进制：用在整数字面量之前添加 “0b” 或者 “0B” 来表示的。  </p><p><strong>在数值字面量中使用下划线</strong></p><p>在 Java7 中，数值字面量，不管是整数还是浮点数都允许在数字之间插入任意多个下划线。并且不会对数值产生影响，目的是方便阅读，规则只能在数字之间使用。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class BinaryIntegralLiteral {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(0b010101);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(0B010101);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(0x15A);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(0X15A);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(077);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        System.out.println(5_000);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         * 输出结果</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         * 21 </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         * 21 </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         * 346 </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         * 346 </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         * 63</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         * 5000</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="六异常处理">六、异常处理<a class="hash-link" href="#六异常处理" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="1-常见异常分为那两种exceptionerror常见异常的基类以及常见的异常">1. 常见异常分为那两种(Exception，Error)，常见异常的基类以及常见的异常<a class="hash-link" href="#1-常见异常分为那两种exceptionerror常见异常的基类以及常见的异常" title="Direct link to heading">​</a></h3><ul><li><p>Throwable 是 Java 语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。 </p></li><li><p>异常种类 </p><ul><li><strong>Error</strong>：Error 为错误，是程序无法处理的，如 OutOfMemoryError、ThreadDeath 等，出现这种情况你唯一能做的就是听之任之，交由 JVM 来处理，不过 JVM 在大多数情况下会选择终止线程。 </li><li><strong>Exception</strong>：Exception 是程序可以处理的异常。它又分为两种 CheckedException（受捡异常），一种是 UncheckedException（不受检异常）。 <ul><li><strong>受检异常</strong>（CheckException）：发生在编译阶段，必须要使用 try…catch（或者throws）否则编译不通过。 </li><li><strong>非受检异常</strong> （UncheckedException）：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序奔溃并且无法恢复。 （发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的，难以排查，我们一般都需要纵观全局才能够发现这类的异常错误，所以在程序设计中我们需要认真考虑，好好写代码，尽量处理异常，即使产生了异常，也能尽量保证程序朝着有利方向发展。 ）</li></ul></li></ul></li><li><p>常见异常的基类（Exception）</p><ul><li>IOException </li><li>RuntimeException </li></ul></li><li><p>常见的异常</p></li></ul><div align="center"><img loading="lazy" src="assets/exception_and_error.png" width="650" class="img_E7b_"></div><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="七object-通用方法">七、Object 通用方法<a class="hash-link" href="#七object-通用方法" title="Direct link to heading">​</a></h2><p>以下为 Object 中的通用方法</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final native Class&lt;?&gt; getClass()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public native int hashCode()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public boolean equals(Object obj)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">protected native Object clone() throws CloneNotSupportedException</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public String toString()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final native void notify()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final native void notifyAll()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final native void wait(long timeout) throws InterruptedException</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final void wait(long timeout, int nanos) throws InterruptedException</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public final void wait() throws InterruptedException</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">protected void finalize() throws Throwable {} // JVM内存回收之finalize()方法</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="equals">equals()<a class="hash-link" href="#equals" title="Direct link to heading">​</a></h3><p><strong>1. equals() 与 == 的区别</strong></p><ul><li>对于基本类型，==  判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，==  判断两个实例是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Integer x = new Integer(1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Integer y = new Integer(1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(x.equals(y)); // true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(x == y);      // false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><strong>2. 等价关系</strong> </p><p>（一）自反性</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">x.equals(x); // true</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>（二）对称性</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">x.equals(y) == y.equals(x); // true</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>（三）传递性</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">if (x.equals(y) &amp;&amp; y.equals(z))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    x.equals(z); // true;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>（四）一致性</p><p>多次调用 equals() 方法结果不变</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">x.equals(y) == x.equals(y); // true</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>（五）与 null 的比较</p><p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">x.euqals(null); // false;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><strong>3. 实现</strong> </p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 实例进行转型；</li><li>判断每个关键域是否相等。</li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class EqualExample {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int x;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int y;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int z;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public EqualExample(int x, int y, int z) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        this.x = x;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        this.y = y;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        this.z = z;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public boolean equals(Object o) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if (this == o) return true;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if (o == null || getClass() != o.getClass()) return false;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        EqualExample that = (EqualExample) o;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if (x != that.x) return false;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if (y != that.y) return false;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return z == that.z;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="hashcode">hashCode()<a class="hash-link" href="#hashcode" title="Direct link to heading">​</a></h3><p>　　hasCode() 返回散列值，而 equals() 是用来判断两个实例是否等价。<strong>等价的两个实例散列值一定要相同，但是散列值相同的两个实例不一定等价。</strong></p><p>　　在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个实例散列值也相等。</p><p>　　下面的代码中，新建了两个等价的实例，并将它们添加到 HashSet 中。我们希望将这两个实例当成一样的，只在集合中添加一个实例，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个实例的散列值是不同的，最终导致集合添加了两个等价的实例。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">EqualExample e1 = new EqualExample(1, 1, 1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">EqualExample e2 = new EqualExample(1, 1, 1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(e1.equals(e2)); // true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">set.add(e1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">set.add(e2);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(set.size());   // 2</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>　　理想的散列函数应当具有均匀性，即不相等的实例应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><p>　　一个数与 31 相乘可以转换成移位和减法：<code>31\*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public int hashCode() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int result = 17;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    result = 31 * result + x;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    result = 31 * result + y;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    result = 31 * result + z;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="tostring">toString()<a class="hash-link" href="#tostring" title="Direct link to heading">​</a></h3><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为<strong>散列码的无符号十六进制</strong>表示。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class ToStringExample {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int number;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    public ToStringExample(int number) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        this.number = number;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">ToStringExample example = new ToStringExample(123);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(example.toString());</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><div class="codeBlockContainer_I0IT language-html theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-html codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">ToStringExample@4554617c</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="clone">clone()<a class="hash-link" href="#clone" title="Direct link to heading">​</a></h3><p><strong>1. cloneable</strong> </p><p>clone() 是 Object 的 protect 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class CloneExample {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int a;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CloneExample e1 = new CloneExample();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>重写 clone() 得到以下实现：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class CloneExample {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int a;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    protected CloneExample clone() throws CloneNotSupportedException {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return (CloneExample)super.clone();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">CloneExample e1 = new CloneExample();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    CloneExample e2 = e1.clone();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">} catch (CloneNotSupportedException e) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    e.printStackTrace();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><div class="codeBlockContainer_I0IT language-html theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-html codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">java.lang.CloneNotSupportedException: CloneTest</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>以上抛出了 CloneNotSupportedException，这是因为 CloneTest 没有实现 Cloneable 接口。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#bfc7d5;background-color:#292d3e"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public class CloneExample implements Cloneable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int a;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    private int b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    protected Object clone() throws CloneNotSupportedException {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return super.clone();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><p>参考资料：</p><ul><li><a href="https://juejin.im/post/5ac4d8abf265da23a4050ae3" target="_blank" rel="noopener noreferrer">【必读】搞懂 Java equals 和 hashCode 方法 - 掘金</a></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="更新日志">更新日志<a class="hash-link" href="#更新日志" title="Direct link to heading">​</a></h2><ul><li>2018/7/11 v1.0 第一版</li><li>2018/7/31 v2.0 基础版</li><li>2018/8/30-31 v3.0 初版</li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/frank-lam/frankfeekr-notes/tree/master/docs/backend/java/01-Java基础.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/backend/java/Java集合框架"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java 集合框架</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#前言" class="table-of-contents__link toc-highlight">前言</a></li><li><a href="#一基本概念" class="table-of-contents__link toc-highlight">一、基本概念</a><ul><li><a href="#1-java程序初始化的顺序是怎么样的" class="table-of-contents__link toc-highlight">1. Java程序初始化的顺序是怎么样的</a></li><li><a href="#2-java和c的区别" class="table-of-contents__link toc-highlight">2. Java和C++的区别</a></li><li><a href="#3-反射" class="table-of-contents__link toc-highlight">3. 反射</a><ul><li><a href="#先看一个知乎回答" class="table-of-contents__link toc-highlight">先看一个知乎回答</a></li><li><a href="#什么是反射" class="table-of-contents__link toc-highlight">什么是反射</a></li><li><a href="#主要用途" class="table-of-contents__link toc-highlight">主要用途</a></li><li><a href="#获得class对象" class="table-of-contents__link toc-highlight">获得Class对象</a></li></ul></li><li><a href="#4-注解" class="table-of-contents__link toc-highlight">4. 注解</a><ul><li><a href="#什么是注解" class="table-of-contents__link toc-highlight">什么是注解</a></li><li><a href="#为什么要用注解" class="table-of-contents__link toc-highlight">为什么要用注解</a></li><li><a href="#基本annotation" class="table-of-contents__link toc-highlight">基本Annotation</a></li><li><a href="#自定义注解类编写规则" class="table-of-contents__link toc-highlight">自定义注解类编写规则</a></li><li><a href="#自定义注解实例" class="table-of-contents__link toc-highlight">自定义注解实例</a></li></ul></li><li><a href="#5-泛型" class="table-of-contents__link toc-highlight">5. 泛型</a><ul><li><a href="#通俗解释" class="table-of-contents__link toc-highlight">通俗解释</a></li><li><a href="#泛型方法" class="table-of-contents__link toc-highlight">泛型方法</a></li><li><a href="#泛型类" class="table-of-contents__link toc-highlight">泛型类</a></li><li><a href="#类型通配符" class="table-of-contents__link toc-highlight">类型通配符</a></li></ul></li><li><a href="#6-字节与字符的区别" class="table-of-contents__link toc-highlight">6. 字节与字符的区别</a></li><li><a href="#7-有哪些访问修饰符" class="table-of-contents__link toc-highlight">7. 有哪些访问修饰符</a></li><li><a href="#8-深拷贝与浅拷贝" class="table-of-contents__link toc-highlight">8. 深拷贝与浅拷贝</a></li><li><a href="#9-lamda表达式" class="table-of-contents__link toc-highlight">9. Lamda表达式</a><ul><li><a href="#语法" class="table-of-contents__link toc-highlight">语法</a></li><li><a href="#lambda-表达式实例" class="table-of-contents__link toc-highlight">Lambda 表达式实例</a></li><li><a href="#变量作用域" class="table-of-contents__link toc-highlight">变量作用域</a></li></ul></li><li><a href="#10-字符串常量池" class="table-of-contents__link toc-highlight">10. 字符串常量池</a></li><li><a href="#11-解释型语言与编译型语言的区别" class="table-of-contents__link toc-highlight">11. 解释型语言与编译型语言的区别</a></li></ul></li><li><a href="#二面向对象" class="table-of-contents__link toc-highlight">二、面向对象</a><ul><li><a href="#1-java的四个基本特性对多态的理解在项目中哪些地方用到多态" class="table-of-contents__link toc-highlight">1. Java的四个基本特性，对多态的理解，在项目中哪些地方用到多态</a></li><li><a href="#2-什么是重载和重写" class="table-of-contents__link toc-highlight">2. 什么是重载和重写</a></li><li><a href="#3-面向对象和面向过程的区别用面向过程可以实现面向对象吗" class="table-of-contents__link toc-highlight">3. 面向对象和面向过程的区别？用面向过程可以实现面向对象吗？</a></li><li><a href="#4-面向对象开发的六个基本原则在项目中用过哪些原则" class="table-of-contents__link toc-highlight">4. 面向对象开发的六个基本原则，在项目中用过哪些原则</a></li><li><a href="#5-内部类有哪些" class="table-of-contents__link toc-highlight">5. 内部类有哪些</a><ul><li><a href="#一成员内部类" class="table-of-contents__link toc-highlight">（一）成员内部类</a></li><li><a href="#二局部内部类" class="table-of-contents__link toc-highlight">（二）局部内部类</a></li><li><a href="#三匿名内部类" class="table-of-contents__link toc-highlight">（三）匿名内部类</a></li><li><a href="#四静态内部类" class="table-of-contents__link toc-highlight">（四）静态内部类</a></li></ul></li><li><a href="#6-组合继承和代理的区别" class="table-of-contents__link toc-highlight">6. 组合、继承和代理的区别</a><ul><li><a href="#定义" class="table-of-contents__link toc-highlight">定义</a></li><li><a href="#使用场合" class="table-of-contents__link toc-highlight">使用场合</a></li></ul></li><li><a href="#7-什么是构造函数" class="table-of-contents__link toc-highlight">7. 什么是构造函数</a></li><li><a href="#8-向上造型和向下造型" class="table-of-contents__link toc-highlight">8. 向上造型和向下造型</a></li></ul></li><li><a href="#三关键字" class="table-of-contents__link toc-highlight">三、关键字</a><ul><li><a href="#1-final与static的区别" class="table-of-contents__link toc-highlight">1. final与static的区别</a><ul><li><a href="#final" class="table-of-contents__link toc-highlight">final</a></li><li><a href="#static" class="table-of-contents__link toc-highlight">static</a></li></ul></li><li><a href="#2-breakcontinuereturn" class="table-of-contents__link toc-highlight">2. break、continue、return</a><ul><li><a href="#break" class="table-of-contents__link toc-highlight">break</a></li><li><a href="#continue" class="table-of-contents__link toc-highlight">continue</a></li><li><a href="#return" class="table-of-contents__link toc-highlight">return</a></li></ul></li><li><a href="#3-finalfinally和finalize区别" class="table-of-contents__link toc-highlight">3. final、finally和finalize区别</a><ul><li><a href="#final-1" class="table-of-contents__link toc-highlight">final</a></li><li><a href="#finally" class="table-of-contents__link toc-highlight">finally</a></li><li><a href="#finalize" class="table-of-contents__link toc-highlight">finalize</a><ul><li><a href="#判定死亡" class="table-of-contents__link toc-highlight">判定死亡</a></li><li><a href="#最后的救赎" class="table-of-contents__link toc-highlight">最后的救赎</a></li><li><a href="#finalize的作用" class="table-of-contents__link toc-highlight">finalize()的作用</a></li></ul></li></ul></li><li><a href="#4-assert有什么作用" class="table-of-contents__link toc-highlight">4. assert有什么作用</a><ul><li><a href="#什么是断言" class="table-of-contents__link toc-highlight">什么是断言</a></li><li><a href="#常用断言方法" class="table-of-contents__link toc-highlight">常用断言方法</a></li></ul></li><li><a href="#5-volatile" class="table-of-contents__link toc-highlight">5. volatile</a></li><li><a href="#6-instanceof" class="table-of-contents__link toc-highlight">6. instanceof</a></li><li><a href="#7-strictfp" class="table-of-contents__link toc-highlight">7. strictfp</a></li><li><a href="#8-transient" class="table-of-contents__link toc-highlight">8. transient</a></li><li><a href="#9-native" class="table-of-contents__link toc-highlight">9. native</a></li></ul></li><li><a href="#四基本数据类型与运算" class="table-of-contents__link toc-highlight">四、基本数据类型与运算</a><ul><li><a href="#1-java的基本数据类型和引用类型自动装箱和拆箱" class="table-of-contents__link toc-highlight">1. Java的基本数据类型和引用类型，自动装箱和拆箱</a></li><li><a href="#2-valueof缓存池" class="table-of-contents__link toc-highlight">2. ValueOf缓存池</a></li><li><a href="#3-i和i有什么区别" class="table-of-contents__link toc-highlight">3. i++和++i有什么区别</a><ul><li><a href="#i" class="table-of-contents__link toc-highlight">i++</a></li><li><a href="#i-1" class="table-of-contents__link toc-highlight">++i</a></li></ul></li><li><a href="#4-位运算符" class="table-of-contents__link toc-highlight">4. 位运算符</a></li><li><a href="#5-原码补码反码是什么" class="table-of-contents__link toc-highlight">5. 原码、补码、反码是什么</a><ul><li><a href="#机器数" class="table-of-contents__link toc-highlight">机器数</a></li><li><a href="#真值" class="table-of-contents__link toc-highlight">真值</a></li><li><a href="#原码" class="table-of-contents__link toc-highlight">原码</a></li><li><a href="#反码" class="table-of-contents__link toc-highlight">反码</a></li><li><a href="#补码" class="table-of-contents__link toc-highlight">补码</a></li></ul></li><li><a href="#6-不用额外变量交换两个整数的值" class="table-of-contents__link toc-highlight">6. 不用额外变量交换两个整数的值</a></li><li><a href="#7-不使用运算符进行ab操作" class="table-of-contents__link toc-highlight">7. 不使用运算符进行a+b操作</a></li><li><a href="#8-和-和的区别" class="table-of-contents__link toc-highlight">8. &amp;和&amp;&amp; 、|和||的区别</a></li></ul></li><li><a href="#五字符串与数组" class="table-of-contents__link toc-highlight">五、字符串与数组</a><ul><li><a href="#1-stringstringbufferstringbuilder以及对string不变性的理解" class="table-of-contents__link toc-highlight">1. String,StringBuffer,StringBuilder，以及对String不变性的理解</a></li><li><a href="#2-string有重写object的hashcode和tostring吗如果重写equals不重写hashcode会出现什么问题" class="table-of-contents__link toc-highlight">2. String有重写Object的hashcode和toString吗？如果重写equals不重写hashcode会出现什么问题？</a></li><li><a href="#3-如果你定义一个类包括学号姓名分数如何把这个对象作为key要重写equals和hashcode吗" class="table-of-contents__link toc-highlight">3. 如果你定义一个类，包括学号，姓名，分数，如何把这个对象作为key？要重写equals和hashcode吗</a></li><li><a href="#4-字面量" class="table-of-contents__link toc-highlight">4. 字面量</a></li></ul></li><li><a href="#六异常处理" class="table-of-contents__link toc-highlight">六、异常处理</a><ul><li><a href="#1-常见异常分为那两种exceptionerror常见异常的基类以及常见的异常" class="table-of-contents__link toc-highlight">1. 常见异常分为那两种(Exception，Error)，常见异常的基类以及常见的异常</a></li></ul></li><li><a href="#七object-通用方法" class="table-of-contents__link toc-highlight">七、Object 通用方法</a><ul><li><a href="#equals" class="table-of-contents__link toc-highlight">equals()</a></li><li><a href="#hashcode" class="table-of-contents__link toc-highlight">hashCode()</a></li><li><a href="#tostring" class="table-of-contents__link toc-highlight">toString()</a></li><li><a href="#clone" class="table-of-contents__link toc-highlight">clone()</a></li></ul></li><li><a href="#更新日志" class="table-of-contents__link toc-highlight">更新日志</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 技术小匠 · 知识笔记</div></div></div></footer></div>
<script src="/assets/js/runtime~main.44680fd1.js"></script>
<script src="/assets/js/main.76edb368.js"></script>
</body>
</html>